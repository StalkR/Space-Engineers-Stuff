//Original: https://steamcommunity.com/sharedfiles/filedetails/?id=2429023481

const string SHIELDDISPLAYTAG = "[SHIELD]";
const string SHIELDGENTAG = "Shield Generator";
const string SHILDDEFTAG = "Sheild Emitter";

List<IMyTerminalBlock> ShieldsArray; 
List<IMyTerminalBlock> LCDsArray;
List<IMyTextSurface> textSurfaces;
readonly MyIni textSurfaceIni = new MyIni();
const string INI_SECTION_TEXT_SURF_PROVIDER = "Shield - Text Surface Config";
const string INI_TEXT_SURFACE_TEMPLATE = "Show on screen {0}";
DefenseShields DefShield;

void AddTextSurfaces(IMyTerminalBlock block, List<IMyTextSurface> textSurfaces)
{
    var textSurface = block as IMyTextSurface;
    if (textSurface != null)
    {
        textSurfaces.Add(textSurface);
        return;
    }

    var surfaceProvider = block as IMyTextSurfaceProvider;
    if (surfaceProvider == null)
        return;

    textSurfaceIni.Clear();
    textSurfaceIni.TryParse(block.CustomData);
    int surfaceCount = surfaceProvider.SurfaceCount;
    for (int i = 0; i < surfaceCount; ++i)
    {
        string iniKey = string.Format(INI_TEXT_SURFACE_TEMPLATE, i);
        bool display = textSurfaceIni.Get(INI_SECTION_TEXT_SURF_PROVIDER, iniKey).ToBoolean(i == 0 && !(block is IMyProgrammableBlock));
        if (display)
            textSurfaces.Add(surfaceProvider.GetSurface(i));

        textSurfaceIni.Set(INI_SECTION_TEXT_SURF_PROVIDER, iniKey, display);
    }

    block.CustomData = textSurfaceIni.ToString();
}

public void SEStatusInit() 
{ 
    // Search for Shileds in Grid 
    ShieldsArray = new List<IMyTerminalBlock>(); 
    GridTerminalSystem.SearchBlocksOfName(SHIELDGENTAG, ShieldsArray);
    DefShield = new DefenseShields(Me);
 
    // Building list of Displays to show status 
    LCDsArray = new List<IMyTerminalBlock>(); 
    GridTerminalSystem.SearchBlocksOfName(SHIELDDISPLAYTAG, LCDsArray); 

    //The New Way
    textSurfaces = new List<IMyTextSurface>();
    for (int i = 0; i < LCDsArray.Count; i++) 
    {  
        if (LCDsArray[i] == null) 
        { 
        } 
        else
        {
            AddTextSurfaces(LCDsArray[i], textSurfaces);
        }
    }
    
} 
 
public Program() 
{ 
    // Setting script for self-update eache 100 ticks = 1.6 sec 
    Runtime.UpdateFrequency = UpdateFrequency.Update100; 
 
    // Call init on 1st run! 
    SEStatusInit(); 
} 
 
public void Save() 
{ 
    // Called when the program needs to save its state. Use 
    // this method to save your state to the Storage field 
    // or some other means.  
    //  
    // This method is optional and can be removed if not 
    // needed. 
} 

public void Main(string argument) 
{
    //Search for changes to grid and connected grids
    GridTerminalSystem.SearchBlocksOfName(SHIELDGENTAG, ShieldsArray); 
    GridTerminalSystem.SearchBlocksOfName(SHIELDDISPLAYTAG, LCDsArray);

    //string ShieldsInfo = "";
    string ShieldsData = ""; 
    string OverallShield = ""; 
    string CurrentShield = ""; 
    string ShieldUnits = "";
    bool ShieldsFound = false;
    float DefenseShieldCharge;
    float DefenseShieldMaxCharge;
    float DefenseShieldPercent;
 
    // Let's read data from shields, if we have them 
    for (int j = 0; j < ShieldsArray.Count; j++) 
    { 
        if (ShieldsArray[j] == null) 
        {  
        }
        else
        {
            ShieldsFound = true;
            //ShieldsInfo = ShieldsInfo + "[[[ Shield N" + j + " ]]]\n"; 
            //ShieldsInfo = ShieldsInfo + "Capacity: " + ShieldsArray[j].CustomInfo.Split('\n')[2].Split(':')[1] + "\n"; 
            //ShieldsInfo = ShieldsInfo + "Charging: " + ShieldsArray[j].CustomInfo.Split('\n')[3].Split(':')[1] + "\n\n"; 
 
            ShieldsData = ShieldsArray[j].CustomInfo.Split('\n')[1]; 
            CurrentShield = ShieldsData.Split(' ')[2]; 
            OverallShield = ShieldsData.Split(' ')[3].Split('/')[1]; 
            ShieldUnits = ShieldsData.Split(' ')[3].Split('/')[0];
        }
    }
    //now the defense shield
    DefenseShieldCharge = DefShield.GetCharge();
    DefenseShieldMaxCharge = DefShield.GetMaxCharge();
    DefenseShieldPercent = DefShield.GetShieldPercent();

    // Loop through all lcds with designated name 
    for (int i = 0; i < textSurfaces.Count; i++) 
    {  
        if (textSurfaces[i] == null) 
        { 
        } 
        else
        {
            textSurfaces[i].WriteText("", false); 
            if (ShieldsFound) 
            {
                textSurfaces[i].WriteText("Structural Shield: " + CurrentShield + " of " + OverallShield + " " + ShieldUnits + "\n", true); 
 
                float Cur = Convert.ToSingle(CurrentShield); 
                float Max = Convert.ToSingle(OverallShield); 
                float prog = (Cur / Max) * 67; 
                float empt = (67 - prog) / 2; 
 
                // Prints the shield strength as progress bar
                for (int k = 0; k < prog; k++) 
                { 
                    textSurfaces[i].WriteText("|", true); 
                }
            } 
            else
            {
                textSurfaces[i].WriteText("Structural Shields Disabled\n-------------------------------------------\n"); 
            }        
        }
        if(DefenseShieldCharge <= 0)
        {
            textSurfaces[i].WriteText("\nDefence Shield Disabled", true);
        } 
        else
        {
            textSurfaces[i].WriteText("\nDefence Shield: " +  DefenseShieldPercent + "% - "+ DefenseShieldCharge + " of " + DefenseShieldMaxCharge + " KW\n", true);
            float progdef = DefenseShieldPercent * 0.67f; 
            // Prints the shield strength as progress bar
            for (int k = 0; k < progdef; k++) 
            { 
                textSurfaces[i].WriteText("|", true); 
            }
            textSurfaces[i].WriteText("\nHeat: " +  DefShield.GetShieldHeat(), true);
            textSurfaces[i].WriteText("\nCharge Rate: " +  DefShield.GetChargeRate(), true);
        }
    } 
} 


public class DefenseShields
{
  private IMyTerminalBlock _block;

  private readonly Func<IMyTerminalBlock, RayD, Vector3D?> _rayIntersectShield;
  private readonly Func<IMyTerminalBlock, LineD, Vector3D?> _lineIntersectShield;
  private readonly Func<IMyTerminalBlock, Vector3D, bool> _pointInShield;
  private readonly Func<IMyTerminalBlock, float> _getShieldPercent;
  private readonly Func<IMyTerminalBlock, int> _getShieldHeat;
  private readonly Func<IMyTerminalBlock, float> _getChargeRate;
  private readonly Func<IMyTerminalBlock, int> _hpToChargeRatio;
  private readonly Func<IMyTerminalBlock, float> _getMaxCharge;
  private readonly Func<IMyTerminalBlock, float> _getCharge;
  private readonly Func<IMyTerminalBlock, float> _getPowerUsed;
  private readonly Func<IMyTerminalBlock, float> _getPowerCap;
  private readonly Func<IMyTerminalBlock, float> _getMaxHpCap;
  private readonly Func<IMyTerminalBlock, bool> _isShieldUp;
  private readonly Func<IMyTerminalBlock, string> _shieldStatus;
  private readonly Func<IMyTerminalBlock, IMyEntity, bool, bool> _entityBypass;

  // Fields below do not require SetActiveShield to be defined first.
  private readonly Func<IMyCubeGrid, bool> _gridHasShield;
  private readonly Func<IMyCubeGrid, bool> _gridShieldOnline;
  private readonly Func<IMyEntity, bool> _protectedByShield;
  private readonly Func<IMyEntity, IMyTerminalBlock> _getShieldBlock;
  private readonly Func<IMyTerminalBlock, bool> _isShieldBlock;
  private readonly Func<Vector3D, IMyTerminalBlock> _getClosestShield;
  private readonly Func<IMyTerminalBlock, Vector3D, double> _getDistanceToShield;
  private readonly Func<IMyTerminalBlock, Vector3D, Vector3D?> _getClosestShieldPoint;

  public void SetActiveShield(IMyTerminalBlock block) => _block = block; // AutoSet to TapiFrontend(block) if shield exists on grid.

  public DefenseShields(IMyTerminalBlock block)
  {
    _block = block;
    var delegates = _block.GetProperty("DefenseSystemsPbAPI")?.As<Dictionary<string, Delegate>>().GetValue(_block);
    if (delegates == null)
      return;

    _rayIntersectShield = (Func<IMyTerminalBlock, RayD, Vector3D?>)delegates["RayIntersectShield"];
    _lineIntersectShield = (Func<IMyTerminalBlock, LineD, Vector3D?>)delegates["LineIntersectShield"];
    _pointInShield = (Func<IMyTerminalBlock, Vector3D, bool>)delegates["PointInShield"];
    _getShieldPercent = (Func<IMyTerminalBlock, float>)delegates["GetShieldPercent"];
    _getShieldHeat = (Func<IMyTerminalBlock, int>)delegates["GetShieldHeat"];
    _getChargeRate = (Func<IMyTerminalBlock, float>)delegates["GetChargeRate"];
    _hpToChargeRatio = (Func<IMyTerminalBlock, int>)delegates["HpToChargeRatio"];
    _getMaxCharge = (Func<IMyTerminalBlock, float>)delegates["GetMaxCharge"];
    _getCharge = (Func<IMyTerminalBlock, float>)delegates["GetCharge"];
    _getPowerUsed = (Func<IMyTerminalBlock, float>)delegates["GetPowerUsed"];
    _getPowerCap = (Func<IMyTerminalBlock, float>)delegates["GetPowerCap"];
    _getMaxHpCap = (Func<IMyTerminalBlock, float>)delegates["GetMaxHpCap"];
    _isShieldUp = (Func<IMyTerminalBlock, bool>)delegates["IsShieldUp"];
    _shieldStatus = (Func<IMyTerminalBlock, string>)delegates["ShieldStatus"];
    _entityBypass = (Func<IMyTerminalBlock, IMyEntity, bool, bool>)delegates["EntityBypass"];
    _gridHasShield = (Func<IMyCubeGrid, bool>)delegates["GridHasShield"];
    _gridShieldOnline = (Func<IMyCubeGrid, bool>)delegates["GridShieldOnline"];
    _protectedByShield = (Func<IMyEntity, bool>)delegates["ProtectedByShield"];
    _getShieldBlock = (Func<IMyEntity, IMyTerminalBlock>)delegates["GetShieldBlock"];
    _isShieldBlock = (Func<IMyTerminalBlock, bool>)delegates["IsShieldBlock"];
    _getClosestShield = (Func<Vector3D, IMyTerminalBlock>)delegates["GetClosestShield"];
    _getDistanceToShield = (Func<IMyTerminalBlock, Vector3D, double>)delegates["GetDistanceToShield"];
    _getClosestShieldPoint = (Func<IMyTerminalBlock, Vector3D, Vector3D?>)delegates["GetClosestShieldPoint"];

    if (!IsShieldBlock())
      _block = GetShieldBlock(_block.CubeGrid) ?? _block;
  }

  public Vector3D? RayIntersectShield(RayD ray) => _rayIntersectShield?.Invoke(_block, ray) ?? null;
  public Vector3D? LineIntersectShield(LineD line) => _lineIntersectShield?.Invoke(_block, line) ?? null;
  public bool PointInShield(Vector3D pos) => _pointInShield?.Invoke(_block, pos) ?? false;
  public float GetShieldPercent() => _getShieldPercent?.Invoke(_block) ?? -1;
  public int GetShieldHeat() => _getShieldHeat?.Invoke(_block) ?? -1;
  public float GetChargeRate() => _getChargeRate?.Invoke(_block) ?? -1;
  public float HpToChargeRatio() => _hpToChargeRatio?.Invoke(_block) ?? -1;
  public float GetMaxCharge() => _getMaxCharge?.Invoke(_block) ?? -1;
  public float GetCharge() => _getCharge?.Invoke(_block) ?? -1;
  public float GetPowerUsed() => _getPowerUsed?.Invoke(_block) ?? -1;
  public float GetPowerCap() => _getPowerCap?.Invoke(_block) ?? -1;
  public float GetMaxHpCap() => _getMaxHpCap?.Invoke(_block) ?? -1;
  public bool IsShieldUp() => _isShieldUp?.Invoke(_block) ?? false;
  public string ShieldStatus() => _shieldStatus?.Invoke(_block) ?? string.Empty;
  public bool EntityBypass(IMyEntity entity, bool remove = false) => _entityBypass?.Invoke(_block, entity, remove) ?? false;
  public bool GridHasShield(IMyCubeGrid grid) => _gridHasShield?.Invoke(grid) ?? false;
  public bool GridShieldOnline(IMyCubeGrid grid) => _gridShieldOnline?.Invoke(grid) ?? false;
  public bool ProtectedByShield(IMyEntity entity) => _protectedByShield?.Invoke(entity) ?? false;
  public IMyTerminalBlock GetShieldBlock(IMyEntity entity) => _getShieldBlock?.Invoke(entity) ?? null;
  public bool IsShieldBlock() => _isShieldBlock?.Invoke(_block) ?? false;
  public IMyTerminalBlock GetClosestShield(Vector3D pos) => _getClosestShield?.Invoke(pos) ?? null;
  public double GetDistanceToShield(Vector3D pos) => _getDistanceToShield?.Invoke(_block, pos) ?? -1;
  public Vector3D? GetClosestShieldPoint(Vector3D pos) => _getClosestShieldPoint?.Invoke(_block, pos) ?? null;
}
